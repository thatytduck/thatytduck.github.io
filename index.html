<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>audio</title>

<style>
html, body {
  margin: 0;
  height: 100%;
}

body {
  background: linear-gradient(
    0deg,       /* 0deg = bottom â†’ top */
    #000e17,    /* bottom color */
    #21003c 80% /* top color */
  );
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: monospace;
  color: #666;
}

.wrap {
  text-align: center;
}

audio {
  width: 260px;
  filter: grayscale(1);
}

input[type="range"] {
  width: 260px;
  margin-top: 10px;
}

/* bottom-left reverse button */
#reverse {
  position: fixed;
  bottom: 16px;
  left: 16px;
}

button, a {
  background: none;
  border: none;
  color: #555;
  font-size: 12px;
  cursor: pointer;
  text-decoration: none;
}

button:hover, a:hover {
  color: #aaa;
}
</style>
</head>

<body>
<div class="wrap">
  <audio id="audio" src="audio.mp3" controls></audio>
  <input id="slider" type="range" min="0" max="100" value="0">
  <a id="download" style="display:none;" download="reversed.wav">download</a>
</div>

<button id="reverse">reverse</button>

<script>
const audio = document.getElementById("audio");
const slider = document.getElementById("slider");
const reverseBtn = document.getElementById("reverse");
const downloadLink = document.getElementById("download");

let ctx;
let buffer;
let reversedURL = null;
let isReversed = false;
const originalURL = "audio.mp3";

// keep slider synced
audio.addEventListener("timeupdate", () => {
  if (!audio.duration) return;
  // check if reversed
  slider.value = isReversed 
    ? (1 - audio.currentTime / audio.duration) * 100
    : (audio.currentTime / audio.duration) * 100;
});

// scrub
slider.addEventListener("input", () => {
  if (!audio.duration) return;
  audio.currentTime = isReversed 
    ? (1 - slider.value / 100) * audio.duration
    : (slider.value / 100) * audio.duration;
});

reverseBtn.onclick = async () => {
  // unlock audio context
  if (!ctx) ctx = new AudioContext();

  // load buffer once
  if (!buffer) {
    const data = await fetch(originalURL).then(r => r.arrayBuffer());
    buffer = await ctx.decodeAudioData(data);
  }

  // generate reversed once
  if (!reversedURL) {
    const reversed = ctx.createBuffer(
      buffer.numberOfChannels,
      buffer.length,
      buffer.sampleRate
    );

    for (let c = 0; c < buffer.numberOfChannels; c++) {
      reversed.getChannelData(c).set(buffer.getChannelData(c).slice().reverse());
    }

    reversedURL = makeWav(reversed);
    downloadLink.href = reversedURL;
    downloadLink.style.display = "block";
  }

  // toggle
  const t = audio.currentTime / audio.duration || 0;

  if (!isReversed) {
    audio.src = reversedURL;
    audio.currentTime = (1 - t) * audio.duration;
    reverseBtn.textContent = "forward";
  } else {
    audio.src = originalURL;
    audio.currentTime = (1 - t) * audio.duration;
    reverseBtn.textContent = "reverse";
  }

  isReversed = !isReversed;
  audio.play();
};

// convert buffer to WAV
function makeWav(buf) {
  const length = buf.length * buf.numberOfChannels * 2 + 44;
  const ab = new ArrayBuffer(length);
  const v = new DataView(ab);
  let o = 0;

  function w(s){ for(let i=0;i<s.length;i++) v.setUint8(o++,s.charCodeAt(i)); }

  w("RIFF"); v.setUint32(o, length - 8, true); o += 4;
  w("WAVEfmt "); v.setUint32(o, 16, true); o += 4;
  v.setUint16(o, 1, true); o += 2;
  v.setUint16(o, buf.numberOfChannels, true); o += 2;
  v.setUint32(o, buf.sampleRate, true); o += 4;
  v.setUint32(o, buf.sampleRate * buf.numberOfChannels * 2, true); o += 4;
  v.setUint16(o, buf.numberOfChannels * 2, true); o += 2;
  v.setUint16(o, 16, true); o += 2;
  w("data"); v.setUint32(o, length - o - 4, true); o += 4;

  for (let i = 0; i < buf.length; i++)
    for (let c = 0; c < buf.numberOfChannels; c++) {
      v.setInt16(o, buf.getChannelData(c)[i] * 32767, true);
      o += 2;
    }

  return URL.createObjectURL(new Blob([v], { type: "audio/wav" }));
}
</script>
</body>
</html>
