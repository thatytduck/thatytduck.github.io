<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>audio</title>

<style>
html, body {
  margin: 0;
  height: 100%;
  background: #0b0b0b;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: monospace;
  color: #666;
}

.wrap {
  text-align: center;
}

audio {
  width: 260px;
  filter: grayscale(1);
}

input[type="range"] {
  width: 260px;
  margin-top: 10px;
}

button, a {
  display: block;
  margin-top: 8px;
  background: none;
  border: none;
  color: #555;
  font-size: 12px;
  cursor: pointer;
  text-decoration: none;
}

button:hover, a:hover {
  color: #aaa;
}
</style>
</head>

<body>
<div class="wrap">
  <!-- Normal audio playback -->
  <audio id="audio" src="audio.mp3" controls></audio>

  <!-- Scrub slider -->
  <input id="slider" type="range" min="0" max="100" value="0">

  <!-- Actions -->
  <button id="reverse">reverse</button>
  <a id="download" style="display:none;" download="reversed.wav">download</a>
</div>

<script>
const audio = document.getElementById("audio");
const slider = document.getElementById("slider");
const reverseBtn = document.getElementById("reverse");
const downloadLink = document.getElementById("download");

let ctx;
let buffer;
let reversedBuffer;
let reversedURL;

// keep slider synced
audio.addEventListener("timeupdate", () => {
  if (!audio.duration) return;
  slider.value = (audio.currentTime / audio.duration) * 100;
});

// scrub audio
slider.addEventListener("input", () => {
  if (!audio.duration) return;
  audio.currentTime = (slider.value / 100) * audio.duration;
});

reverseBtn.onclick = async () => {
  // unlock audio context on click
  if (!ctx) ctx = new AudioContext();

  // load and decode
  if (!buffer) {
    const data = await fetch("audio.mp3").then(r => r.arrayBuffer());
    buffer = await ctx.decodeAudioData(data);
  }

  // reverse buffer
  reversedBuffer = ctx.createBuffer(
    buffer.numberOfChannels,
    buffer.length,
    buffer.sampleRate
  );

  for (let c = 0; c < buffer.numberOfChannels; c++) {
    reversedBuffer
      .getChannelData(c)
      .set(buffer.getChannelData(c).slice().reverse());
  }

  // export wav
  reversedURL = makeWav(reversedBuffer);

  // switch audio element to reversed version
  audio.src = reversedURL;
  audio.play();

  downloadLink.href = reversedURL;
  downloadLink.style.display = "block";
};

function makeWav(buf) {
  const length = buf.length * buf.numberOfChannels * 2 + 44;
  const ab = new ArrayBuffer(length);
  const v = new DataView(ab);
  let o = 0;

  function w(s){ for(let i=0;i<s.length;i++) v.setUint8(o++,s.charCodeAt(i)); }

  w("RIFF"); v.setUint32(o, length - 8, true); o += 4;
  w("WAVEfmt "); v.setUint32(o, 16, true); o += 4;
  v.setUint16(o, 1, true); o += 2;
  v.setUint16(o, buf.numberOfChannels, true); o += 2;
  v.setUint32(o, buf.sampleRate, true); o += 4;
  v.setUint32(o, buf.sampleRate * buf.numberOfChannels * 2, true); o += 4;
  v.setUint16(o, buf.numberOfChannels * 2, true); o += 2;
  v.setUint16(o, 16, true); o += 2;
  w("data"); v.setUint32(o, length - o - 4, true); o += 4;

  for (let i = 0; i < buf.length; i++) {
    for (let c = 0; c < buf.numberOfChannels; c++) {
      v.setInt16(o, buf.getChannelData(c)[i] * 32767, true);
      o += 2;
    }
  }

  return URL.createObjectURL(new Blob([v], { type: "audio/wav" }));
}
</script>
</body>
</html>
